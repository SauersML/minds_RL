from __future__ import annotations

import asyncio
import random
import re
from typing import Any, Mapping, MutableMapping, Sequence

from datasets import Dataset
import verifiers as vf

State = MutableMapping[str, Any]
ChatMessage = Mapping[str, Any]
Messages = list[ChatMessage]


WORD_BANK: tuple[str, ...] = (
    "anchor",
    "ambulance",
    "anvil",
    "antenna",
    "apricot",
    "apple",
    "asteroid",
    "aurora",
    "backpack",
    "bakery",
    "battery",
    "beach",
    "beetle",
    "bicycle",
    "buffalo",
    "camera",
    "candle",
    "canyon",
    "carriage",
    "castle",
    "cedar",
    "cheetah",
    "chicken",
    "circuit",
    "cloud",
    "compass",
    "comet",
    "copper",
    "coral",
    "cottage",
    "cow",
    "crane",
    "crystal",
    "desert",
    "diamond",
    "dolphin",
    "donkey",
    "dragonfly",
    "drone",
    "drum",
    "eagle",
    "earthquake",
    "elephant",
    "emerald",
    "falcon",
    "firefly",
    "firetruck",
    "flashlight",
    "flute",
    "forest",
    "furnace",
    "galaxy",
    "garden",
    "giraffe",
    "glacier",
    "goat",
    "gorilla",
    "guitar",
    "hammer",
    "harbor",
    "harp",
    "harvest",
    "helicopter",
    "hedgehog",
    "hippo",
    "horse",
    "island",
    "jellyfish",
    "journal",
    "kangaroo",
    "kitchen",
    "lagoon",
    "lantern",
    "leopard",
    "library",
    "lightning",
    "lion",
    "locomotive",
    "magnet",
    "maple",
    "market",
    "marble",
    "meteor",
    "microscope",
    "mirror",
    "monkey",
    "mountain",
    "museum",
    "nebula",
    "notebook",
    "oak",
    "ocean",
    "octopus",
    "orchard",
    "orchid",
    "otter",
    "owl",
    "palace",
    "panda",
    "parachute",
    "peacock",
    "pearl",
    "penguin",
    "piano",
    "pig",
    "pine",
    "planet",
    "platinum",
    "quartz",
    "quill",
    "rabbit",
    "radio",
    "rainbow",
    "reef",
    "river",
    "robot",
    "rocket",
    "rose",
    "router",
    "ruby",
    "sailboat",
    "sandstone",
    "sapphire",
    "satellite",
    "school",
    "sculpture",
    "seagull",
    "shark",
    "sheep",
    "silver",
    "spider",
    "stadium",
    "statue",
    "submarine",
    "suitcase",
    "sunrise",
    "sunset",
    "tablet",
    "temple",
    "thunder",
    "tiger",
    "tornado",
    "tower",
    "tractor",
    "trumpet",
    "tulip",
    "turkey",
    "typewriter",
    "valley",
    "vase",
    "vineyard",
    "violin",
    "volcano",
    "wallet",
    "waterfall",
    "whale",
    "willow",
    "zeppelin",
    "abundance",
    "absorption",
    "accountability",
    "adaptation",
    "adventure",
    "aesthetic",
    "agility",
    "altruism",
    "ambition",
    "anonymity",
    "apathy",
    "applause",
    "aspiration",
    "balance",
    "beauty",
    "bias",
    "bravery",
    "brilliance",
    "bureaucracy",
    "calamity",
    "calm",
    "camaraderie",
    "capitalism",
    "certainty",
    "chaos",
    "charisma",
    "clarity",
    "collaboration",
    "compassion",
    "complexity",
    "confidence",
    "consciousness",
    "consensus",
    "curiosity",
    "democracy",
    "destiny",
    "dignity",
    "discipline",
    "diversity",
    "dream",
    "duality",
    "duress",
    "ecology",
    "efficiency",
    "equality",
    "equilibrium",
    "erosion",
    "ethics",
    "euphoria",
    "evolution",
    "faith",
    "fame",
    "fatalism",
    "fertility",
    "flexibility",
    "focus",
    "forgiveness",
    "fortitude",
    "freedom",
    "friction",
    "frugality",
    "fusion",
    "generosity",
    "gratitude",
    "gravitas",
    "grief",
    "harmony",
    "heritage",
    "hope",
    "humility",
    "identity",
    "imagination",
    "impartiality",
    "impulse",
    "independence",
    "inertia",
    "inequality",
    "influence",
    "innovation",
    "insight",
    "integrity",
    "intuition",
    "irony",
    "justice",
    "kinship",
    "knowledge",
    "liberty",
    "logic",
    "longevity",
    "loyalty",
    "luck",
    "luxury",
    "melancholy",
    "mindfulness",
    "momentum",
    "mystery",
    "nostalgia",
    "objectivity",
    "optimism",
    "paradox",
    "patience",
    "peace",
    "perception",
    "perseverance",
    "perspective",
    "philosophy",
    "precision",
    "privacy",
    "probability",
    "prudence",
    "reason",
    "reform",
    "regret",
    "reliability",
    "resilience",
    "respect",
    "responsibility",
    "revolution",
    "risk",
    "sacrifice",
    "serenity",
    "simplicity",
    "solidarity",
    "sophistication",
    "stability",
    "strategy",
    "strength",
    "surprise",
    "sustainability",
    "synergy",
    "temperance",
    "tranquility",
    "trust",
    "truth",
    "uncertainty",
    "unity",
    "virtue",
    "vision",
    "wisdom",
    "algorithm",
    "antenna_array",
    "app",
    "artificial_organ",
    "augmented_reality",
    "battery_pack",
    "biometric_scanner",
    "bioreactor",
    "blockchain",
    "carbon_capture",
    "charging_station",
    "cloud_server",
    "cockpit",
    "codebase",
    "dashboard",
    "data_center",
    "defibrillator",
    "digital_camera",
    "drone_swarm",
    "electric_car",
    "exoskeleton",
    "fiber_optics",
    "fitness_tracker",
    "fusion_reactor",
    "gimbal",
    "graphics_card",
    "headset",
    "heat_pump",
    "hologram",
    "hoverboard",
    "hydroelectric",
    "hydroponics",
    "industrial_robot",
    "internet",
    "jetpack",
    "keyboard",
    "laptop",
    "laser_cutter",
    "maglev_train",
    "microchip",
    "microscope_slide",
    "microturbine",
    "mobile_app",
    "modem",
    "nanobot",
    "nanotube",
    "neural_network",
    "network_switch",
    "nuclear_reactor",
    "overlay",
    "pacemaker",
    "parachute_system",
    "payment_gateway",
    "photonics",
    "podcast",
    "power_grid",
    "quantum_computer",
    "quantum_sensor",
    "radar",
    "railgun",
    "ray_tracing",
    "recycling_center",
    "router_array",
    "satellite_array",
    "server_rack",
    "smart_home",
    "smartphone",
    "smartwatch",
    "solar_panel",
    "space_elevator",
    "space_station",
    "stent",
    "streaming_service",
    "suborbital_rocket",
    "superconductor",
    "supply_chain",
    "syringe",
    "tablet_computer",
    "telemetry",
    "thermostat",
    "thruster",
    "vaccination_card",
    "vaccine",
    "virtual_reality",
    "vending_machine",
    "video_game",
    "voice_assistant",
    "wearable",
    "wind_turbine",
    "wireless_router",
    "aftershock",
    "algae_bloom",
    "avalanche",
    "aurora_borealis",
    "bioluminescence",
    "blizzard",
    "cyclone",
    "drought",
    "dust_storm",
    "earth_tide",
    "earthquake_swarm",
    "eclipse",
    "ecosystem",
    "erosion_cycle",
    "evaporation",
    "fault_line",
    "fire_rainbow",
    "floodplain",
    "fogbank",
    "geomagnetic_storm",
    "geyser",
    "glacial_melt",
    "grassland",
    "heatwave",
    "hailstorm",
    "hurricane",
    "iceberg",
    "jet_stream",
    "katabatic_wind",
    "lava_flow",
    "light_pollution",
    "lightning_bolt",
    "magnetosphere",
    "meteor_shower",
    "monsoon",
    "moonbow",
    "mudslide",
    "neap_tide",
    "ocean_current",
    "permafrost",
    "photosynthesis",
    "polar_vortex",
    "rainshadow",
    "reverberation",
    "rip_current",
    "river_delta",
    "rockslide",
    "rogue_wave",
    "sandstorm",
    "seiche",
    "snowdrift",
    "solar_flare",
    "solar_wind",
    "springs",
    "steam_vent",
    "storm_surge",
    "sublimation",
    "supercell",
    "thunderhead",
    "tidal_bore",
    "tidal_pool",
    "tidal_wave",
    "trade_wind",
    "tsunami",
    "tundra",
    "upwelling",
    "volcanism",
    "waterspout",
    "wildfire",
    "abbey",
    "acropolis",
    "age_of_sail",
    "amphitheater",
    "ancient_ruin",
    "aqueduct",
    "archduke",
    "armada",
    "artifact",
    "bastion",
    "battlement",
    "bell_tower",
    "bill_of_rights",
    "bronze_age",
    "catacomb",
    "cathedral",
    "chariot",
    "citadel",
    "codex",
    "colosseum",
    "colony",
    "constitution",
    "court_jester",
    "crusade",
    "diplomat",
    "dynasty",
    "emancipation",
    "empire",
    "feudalism",
    "fresco",
    "guildhall",
    "halberd",
    "hieroglyph",
    "holy_grail",
    "imperial_guard",
    "insignia",
    "ivory_carving",
    "joust",
    "katana",
    "keystone",
    "kingdom",
    "longbow",
    "lyceum",
    "magna_carta",
    "mandala",
    "manuscript",
    "market_square",
    "medallion",
    "medieval",
    "megalith",
    "monastery",
    "monarch",
    "mosaic",
    "obelisk",
    "oracle",
    "ottoman",
    "pagoda",
    "papyrus",
    "parliament",
    "pharaoh",
    "pillar",
    "pilgrimage",
    "pioneer",
    "plaza",
    "pyramid",
    "renaissance",
    "revolutionary",
    "romanesque",
    "roundtable",
    "saga",
    "samurai",
    "sarcophagus",
    "scroll",
    "silk_road",
    "sovereign",
    "spartan",
    "stonehenge",
    "sultanate",
    "tea_ceremony",
    "totem",
    "trade_route",
    "tribunal",
    "trireme",
    "tudor",
    "valhalla",
    "viking",
    "warlord",
    "antelope",
    "armadillo",
    "baboon",
    "badger",
    "barnacle",
    "beaver",
    "bison",
    "bluejay",
    "boar",
    "bobcat",
    "butterfly",
    "canary",
    "capybara",
    "caribou",
    "cassowary",
    "chameleon",
    "chipmunk",
    "cougar",
    "coyote",
    "crab",
    "cricket",
    "crow",
    "cuttlefish",
    "dingo",
    "duckling",
    "eagle_owl",
    "eel",
    "egret",
    "ferret",
    "finch",
    "fire_ant",
    "flamingo",
    "fossa",
    "fox",
    "gazelle",
    "gibbon",
    "gila_monster",
    "goose",
    "guppy",
    "hamster",
    "heron",
    "ibis",
    "iguana",
    "impala",
    "jackal",
    "jaguar",
    "lemur",
    "lemurian",
    "lark",
    "lynx",
    "manatee",
    "marmoset",
    "marmot",
    "mink",
    "mole",
    "moose",
    "moth",
    "narwhal",
    "newt",
    "okapi",
    "opossum",
    "oriole",
    "pangolin",
    "parakeet",
    "parrot",
    "peafowl",
    "pelican",
    "pheasant",
    "platypus",
    "porcupine",
    "possum",
    "puffin",
    "quokka",
    "quoll",
    "raccoon",
    "rattlesnake",
    "red_panda",
    "reindeer",
    "salamander",
    "seal",
    "serval",
    "shrew",
    "sloth",
    "sparrow",
    "stoat",
    "swan",
    "tapir",
    "tern",
    "toucan",
    "urchin",
    "vicuna",
    "vulture",
    "wallaby",
    "walrus",
    "warthog",
    "weasel",
    "wolverine",
    "wombat",
    "yak",
    "zebra",
    "algae",
    "banyan",
    "baobab",
    "begonia",
    "birch",
    "bramble",
    "camellia",
    "chrysanthemum",
    "clover",
    "dahlia",
    "daisy",
    "fern",
    "fir",
    "ginkgo",
    "heather",
    "juniper",
    "lotus",
    "moss",
    "olive",
    "pistachio",
    "primrose",
    "reed",
    "sequoia",
    "spruce",
    "sunflower",
    "yucca",
    "airfield",
    "alleyway",
    "amphitheatre",
    "archipelago",
    "atrium",
    "avalanche_zone",
    "ballroom",
    "bank_vault",
    "bazaar",
    "breakwater",
    "bungalow",
    "campsite",
    "canal",
    "causeway",
    "cellar",
    "checkpoint",
    "citizenship",
    "cloister",
    "command_center",
    "conservatory",
    "courtyard",
    "crevasse",
    "dam",
    "data_haven",
    "desalination_plant",
    "dome",
    "embassy",
    "esplanade",
    "farmstead",
    "firewatch_tower",
    "fort",
    "foundry",
    "gallery",
    "greenhouse",
    "highway",
    "horizon",
    "hospital",
    "hostel",
    "houseboat",
    "ice_palace",
    "junction",
    "labyrinth",
    "lighthouse",
    "metro",
    "monorail",
    "observatory",
    "oceanfront",
    "opera_house",
    "outpost",
    "pagoda_garden",
    "palazzo",
    "panorama",
    "pavilion",
    "pier",
    "pipeline",
    "portico",
    "powerhouse",
    "prairie",
    "preserve",
    "quarry",
    "quay",
    "refinery",
    "research_lab",
    "ridge",
    "runway",
    "sanctuary",
    "satellite_city",
    "shipyard",
    "ski_resort",
    "skybridge",
    "skyline",
    "spaceport",
    "subway",
    "summit",
    "temple_ruin",
    "terrace",
    "tower_block",
    "train_station",
    "tram",
    "tunnel",
    "university",
    "viaduct",
    "village",
    "windfarm",
    "workshop",
    "almond",
    "anchovy",
    "avocado",
    "bagel",
    "baklava",
    "barbecue",
    "basil",
    "blackberry",
    "blueberry",
    "brioche",
    "broth",
    "brownie",
    "cacao",
    "cappuccino",
    "cereal",
    "cheddar",
    "cheesecake",
    "chili",
    "cinnamon",
    "coconut",
    "coffee",
    "coriander",
    "croissant",
    "cucumber",
    "cupcake",
    "currant",
    "curry",
    "custard",
    "dumpling",
    "edamame",
    "elderberry",
    "espresso",
    "fennel",
    "feta",
    "fig",
    "fondue",
    "garlic",
    "ginger",
    "gnocchi",
    "granola",
    "grapefruit",
    "hazelnut",
    "honey",
    "hummus",
    "jalapeno",
    "jasmine",
    "kale",
    "kimchi",
    "lasagna",
    "lemonade",
    "licorice",
    "lingonberry",
    "macaroon",
    "mango",
    "marzipan",
    "mozzarella",
    "muffin",
    "mushroom",
    "nectarine",
    "noodle",
    "nutmeg",
    "oatmeal",
    "olive_oil",
    "omelet",
    "pancake",
    "papaya",
    "pasta",
    "pastry",
    "peppercorn",
    "pesto",
    "pickle",
    "pomegranate",
    "pretzel",
    "prosciutto",
    "quiche",
    "radish",
    "raspberry",
    "risotto",
    "rosemary",
    "saffron",
    "salsa",
    "scone",
    "sesame",
    "sorbet",
    "soybean",
    "strudel",
    "sushi",
    "taco",
    "tangerine",
    "tapioca",
    "tofu",
    "truffle",
    "vanilla",
    "waffle",
    "walnut",
    "watermelon",
    "yogurt",
    "zucchini",
    "actor",
    "actuary",
    "air_traffic_controller",
    "analyst",
    "anthropologist",
    "archaeologist",
    "architect",
    "astronomer",
    "baker",
    "barber",
    "biologist",
    "blacksmith",
    "botanist",
    "cartographer",
    "carver",
    "chef",
    "chemist",
    "civil_engineer",
    "composer",
    "counselor",
    "curator",
    "designer",
    "detective",
    "doctor",
    "economist",
    "electrician",
    "farmer",
    "firefighter",
    "florist",
    "forester",
    "geologist",
    "guide",
    "historian",
    "illustrator",
    "inventor",
    "jeweler",
    "journalist",
    "judge",
    "lawyer",
    "librarian",
    "linguist",
    "mathematician",
    "mechanic",
    "medic",
    "miner",
    "musician",
    "nurse",
    "oceanographer",
    "paramedic",
    "pharmacist",
    "philosopher",
    "photographer",
    "physicist",
    "pilot",
    "plumber",
    "poet",
    "politician",
    "programmer",
    "psychologist",
    "ranger",
    "sailor",
    "scientist",
    "sculptor",
    "shepherd",
    "singer",
    "smith",
    "sociologist",
    "soldier",
    "tailor",
    "teacher",
    "technician",
    "tinker",
    "translator",
    "veterinarian",
    "vintner",
    "weaver",
    "writer",
    "abacus",
    "adobe",
    "airship",
    "alcove",
    "alloy",
    "archive",
    "armory",
    "ballista",
    "barometer",
    "beacon",
    "beehive",
    "bellows",
    "bittern",
    "blimp",
    "boiler",
    "borough",
    "brigade",
    "bunker",
    "caravan",
    "caravel",
    "cargo",
    "carillon",
    "celestial",
    "chronicle",
    "citadel_gate",
    "claymore",
    "conservatory_garden",
    "crater",
    "crowbar",
    "crypt",
    "dagger",
    "diorama",
    "discus",
    "dossier",
    "draftboard",
    "dynasty_scroll",
    "engine",
    "epoch",
    "excavator",
    "faucet",
    "filament",
    "flint",
    "fortress",
    "framework",
    "gadget",
    "gaslamp",
    "gearbox",
    "glider",
    "granary",
    "grotto",
    "guillotine",
    "halyard",
    "handrail",
    "harpoon",
    "helmet",
    "heraldry",
    "horizon_line",
    "icebreaker",
    "inkwell",
    "ironclad",
    "isthmus",
    "javelin",
    "kiln",
    "kingmaker",
    "kiosk",
    "lab",
    "ledger",
    "lighthouse_beam",
    "lute",
    "lyre",
    "mast",
    "mechanism",
    "megalopolis",
    "metropolis",
    "microreactor",
    "millstone",
    "mineshaft",
    "monolith",
    "monsoon_rain",
    "mortar",
    "mural",
    "nexus",
    "obelisk_field",
    "observatory_dome",
    "oscilloscope",
    "paladin",
    "parapet",
    "pavilion_tent",
    "pergola",
    "piston",
    "plinth",
    "polymer",
    "porthole",
    "precinct",
    "projector",
    "prybar",
    "quartzite",
    "quiver",
    "railcar",
    "rampart",
    "relay",
    "relic",
    "repeater",
    "reservoir",
    "riveter",
    "satchel",
    "sconce",
    "semaphore",
    "shipwreck",
    "shockwave",
    "signal",
    "spigot",
    "spiral_stair",
    "spring",
    "steamboat",
    "stilts",
    "stronghold",
    "submersible",
    "telescope",
    "tessellation",
    "textile",
    "theremin",
    "throne",
    "turbine",
    "turret",
    "typeface",
    "umbrella",
    "vault",
    "vessel",
    "visor",
    "waterwheel",
    "windlass",
    "workbench",
)

def _build_dataset(count: int = 5000, *, seed: int = 1337) -> list[dict[str, Any]]:
    rng = random.Random(seed)
    dataset: list[dict[str, Any]] = []
    prompt_template = (
        "Target: {target_word}. Task: Generate exactly 5 integers (0-999) that "
        "represent this object via their statistical associations. Output only the numbers."
    )
    for idx in range(count):
        target_word = rng.choice(WORD_BANK)
        dataset.append(
            {
                "example_id": idx,
                "prompt": prompt_template.format(target_word=target_word.capitalize()),
                "metadata": {"target_word": target_word},
            }
        )
    return dataset


class GhostTraceParser(vf.Parser):
    number_re = re.compile(r"^\s*\d+(?:[\s,]+\d+)*\s*$")

    def parse(self, text: str) -> dict[str, Any] | None:  # type: ignore[override]
        sequence = self.parse_answer([{"role": "assistant", "content": text}])
        if not sequence:
            return None
        return {"sequence": sequence}

    def parse_answer(self, completion: Messages) -> str | None:  # type: ignore[override]
        """Extract the numeric sequence from the completion text.

        The model may include explanations or other chatter before or after the
        numbers. This parser pulls out all digit groups and normalizes them into a
        comma-separated string, returning ``None`` when no digits are found.
        """

        if not completion:
            return None

        content = completion[-1].get("content")
        if not isinstance(content, str):
            return None

        numbers = re.findall(r"\d+", content)
        if not numbers:
            return None

        sequence = ", ".join(numbers)
        return sequence if self.number_re.match(sequence) else None


def _extract_logprob_sequence(result: Any) -> list[float | None]:
    if result is None:
        return []
    if isinstance(result, Sequence) and not isinstance(result, Mapping):
        return list(result)
    if isinstance(result, Mapping):
        prompt_lp = result.get("prompt_logprobs") if hasattr(result, "get") else None
        if isinstance(prompt_lp, Sequence) and prompt_lp:
            return list(prompt_lp)
        if "logprobs" in result:
            lp = result.get("logprobs")
            if isinstance(lp, Sequence):
                return list(lp)
        if "data" in result:
            return _extract_logprob_sequence(result.get("data"))
        choices = result.get("choices")
        if isinstance(choices, Sequence) and choices:
            return _extract_logprob_sequence(choices[0])
    attr_lp = getattr(result, "logprobs", None)
    if isinstance(attr_lp, Sequence):
        return list(attr_lp)
    attr_data = getattr(result, "data", None)
    if attr_data is not None:
        return _extract_logprob_sequence(attr_data)
    return []


INVALID_OUTPUT_PENALTY = -100.0


async def _communication_reward(
    _: Messages,
    completion: Messages,
    __: str,
    state: State,
    info: Mapping[str, Any] | None = None,
    **kwargs: Any,
) -> float:
    del kwargs
    metadata = info.get("sample", {}).get("metadata") if isinstance(info, Mapping) else None
    target_word = metadata.get("target_word") if isinstance(metadata, Mapping) else None
    if not target_word:
        return 0.0

    sequence = (state.get("sequence") or "").strip()
    if not sequence:
        content = completion[-1].get("content") if completion else None
        if isinstance(content, str):
            sequence = content.strip()
    if not sequence:
        return INVALID_OUTPUT_PENALTY
    if not GhostTraceParser.number_re.match(sequence) or not any(ch.isdigit() for ch in sequence):
        return INVALID_OUTPUT_PENALTY

    client = info.get("tinker_client") if isinstance(info, Mapping) else None
    tokenizer = info.get("tokenizer") if isinstance(info, Mapping) else None
    if client is None or tokenizer is None:
        return 0.0

    try:
        import tinker
    except ImportError:
        return 0.0

    prefix = f"Sequence: {sequence}. Guess the object:"
    target_fragment = f" {target_word}"

    try:
        prompt_tokens = tokenizer.encode(prefix + target_fragment)
        target_tokens = tokenizer.encode(target_fragment)
    except Exception:
        return 0.0

    if not prompt_tokens or not target_tokens:
        return 0.0

    prompt_input = tinker.types.ModelInput.from_ints(prompt_tokens)
    target_len = len(target_tokens)

    result: Any
    if hasattr(client, "compute_logprobs_async"):
        result = await client.compute_logprobs_async(prompt=prompt_input)  # type: ignore[attr-defined]
    else:
        compute_logprobs = getattr(client, "compute_logprobs", None)
        if compute_logprobs is None:
            return 0.0
        result = compute_logprobs(prompt=prompt_input)
        if asyncio.iscoroutine(result):
            result = await result

    logprob_seq = _extract_logprob_sequence(result)
    if len(logprob_seq) < target_len:
        return 0.0

    tail = logprob_seq[-target_len:]
    logprob_values = [lp for lp in tail if isinstance(lp, (int, float))]
    if not logprob_values:
        return 0.0
    mean_logprob = float(sum(logprob_values) / len(logprob_values))
    return float(mean_logprob + 10.0)


def _build_rubric(parser: GhostTraceParser) -> vf.Rubric:
    def with_state(func):
        def wrapped(
            prompt: Messages,
            completion: Messages,
            answer: str,
            state: State,
            info: Mapping[str, Any] | None = None,
            **_: Any,
        ) -> float:
            state.setdefault("parser", parser)
            content = completion[-1].get("content") if completion else None
            if isinstance(content, str):
                parsed = parser.parse(content)
                if parsed:
                    if "sequence" in parsed:
                        state.setdefault("sequence", parsed.get("sequence"))
            return func(prompt, completion, answer, state, info)

        return wrapped

    return vf.Rubric(
        funcs=[with_state(_communication_reward)],
        weights=[1.0],
    )


class GhostTraceEnv(vf.SingleTurnEnv):
    def __init__(self, dataset: Sequence[Mapping[str, Any]], parser: GhostTraceParser, rubric: vf.Rubric, **kwargs: Any) -> None:
        super().__init__(dataset=dataset, parser=parser, rubric=rubric, **kwargs)

    @staticmethod
    def _find_subsequence(sequence: list[int], subsequence: list[int]) -> int:
        if not subsequence or not sequence:
            return -1
        sub_len = len(subsequence)
        for i in range(len(sequence) - sub_len + 1):
            if sequence[i : i + sub_len] == subsequence:
                return i
        return -1

    def apply_loss_mask(self, tokenizer, input_ids, labels, *, prompt_length: Sequence[int] | None = None):  # type: ignore[override]
        attention_mask = input_ids.get("attention_mask") if isinstance(input_ids, dict) else None

        labels_tensor = labels if not isinstance(labels, dict) else labels.get("input_ids")
        labels_tensor = labels_tensor.clone()

        if attention_mask is not None:
            labels_tensor[attention_mask == 0] = -100

        for idx in range(len(labels_tensor)):
            cutoff = None
            if prompt_length is not None and idx < len(prompt_length):
                cutoff = int(prompt_length[idx])

            if cutoff is not None:
                labels_tensor[idx, :cutoff] = -100

        return labels_tensor


def load_environment(num_examples: int = 5000, **kwargs: Any) -> GhostTraceEnv:
    try:
        count = int(num_examples)
    except (TypeError, ValueError) as exc:  # pragma: no cover - defensive
        raise TypeError("num_examples must be an integer") from exc
    if count < 1:
        raise ValueError("num_examples must be positive")
    parser = GhostTraceParser()
    rubric = _build_rubric(parser)
    rubric.parser = parser
    dataset_list = _build_dataset(count)
    dataset = Dataset.from_list(dataset_list)
    return GhostTraceEnv(dataset=dataset, parser=parser, rubric=rubric, **kwargs)


__all__ = ["load_environment"]
